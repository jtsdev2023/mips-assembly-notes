<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SDEV-310 Notes</title>
    <style>
      body {
        font-family: sans-serif;
        font-size: 62.5%;
      }

      main {
        font-size: 1.2rem;
      }
      li {
        padding-bottom: 1rem;
      }
      .h2-span {
        font-size: 2.5rem;
        font-weight: bolder;
        font-family: serif;
      }
      ol > li::marker {
        font-weight: bold; /* bold list item bullet/number */
      }
      code {
        color: rgb(0, 0, 100);
      }
    </style>
  </head>
  <body>
    <main>
      <h1>MIPS Architecture Notes</h1>
      <section>
        <h2>Chapter 1</h2>
        <span class="h2-span">The MIPS Architecture</span>
        <article>
          <h3>1.12 Summary</h3>
          <p>
            When we write a program in assembly language we are creating a list
            of instructions that we want the processor to perform to accomplish
            some task (an algorithm). As soon as we have acquired a functional
            mode of the processor and know exactly what instructions the
            processor can perform, then we will have mastered the first
            necessary componment to becoming a MIPS assembly language
            programmer.
          </p>
          <p>
            The continuous step-by-step functional operation of our simplified
            model for the MIPS architecture can be described as:
          </p>
          <ol>
            <li>
              An instruction is fetched from memory at the location specified by
              the Program Counter. The instruction is loaded into the
              Instruction Register (IR). The Program Counter is incremented y 4.
            </li>
            <li>
              Two 5-bit codes <code>Rs</code> and <code>Rt</code> within the
              instruction specify which register file locations are accessed to
              obtain two 32-bit source operands.
            </li>
            <li>
              The two 32-bit source operands are routed to the ALU inputs where
              some operation is performed depending upon the Op-Code in the
              instruction.
            </li>
            <li>
              The result of the operation is placed back into the register file
              at a location specified by the 5-bit <code>Rd</code> code in the
              IR.
              <br />
              Go to step 1.
            </li>
          </ol>
        </article>
      </section>
      <section>
        <h2>Chapter 2</h2>
        <span class="h2-span">Pseudocode</span>
        <article>
          <h3>2.1 Introduction</h3>
          <p>
            Experienced programmers develop their algorithms using high-level
            programming constructs such as:
          </p>
          <pre>
            <code>
if (condition) do { this block of code } else do { that block of code };
while (condition) do { this block of code };
for (t0=1, t0 &lt; s0, t0++) do { this block of code };
            </code>
            </pre>
          <p>
            The key to making MIPS assembly language programming easy is to
            initially develop the algorithm using a high level
            <span style="font-weight: bold">pseudocode</span> notation with
            which we are already familiar. Then in the final phase, translate
            these high level pseudocode expressions into MIPS assembly language.
            In other words, in the final phase we are performing the same
            function that a compiler performs, which is to translate high-level
            code into the equivalent assembly language code.
          </p>
        </article>
        <article>
          <h3>2.2 Develop the Algorithm in Pseudocode</h3>
          <p>
            When documenting an algorithm in a language such as Pascal, C, C++,
            or JAVA, programmers use descriptive variable names such as:
            <span style="font-family: monospace">
              speed, volume, size, count, amount
            </span>
            etc. After the program is compiled, these variable names correspond
            to memory locations, and the values stored in these memory locations
            correspond to the values of these variables that are referenced most
            often in processor registers, because access to a variable in a
            processor register is faster than access to RAM. MIPS has 32
            processor registers whose name were defined in Table 1.1. In the
            case of the MIPS architecture, all of the data manipulation
            instructions and the control instructions require that their
            operands be in the register file.
          </p>
          <p>
            A MIPS assembly language programmer must specify within each
            instruction which processor registers are going to be utilized. For
            example, we may have a value in register
            <code>$t0</code> corresponding to "speed", a value in register
            <code>$t1</code> corresponding to "volume", a value in register
            <code>$t2</code> corresponding to "size", and a value in register
            <code>$t3</code> corresponding to "count". When using pseudocode to
            document an assembly language program, we must use the names of the
            registers we intend to use in the assembly language code. It is
            advisable to create a cross-reference table that defines what each
            processor register is being used for within the algorithm (For
            example <code>$t0: Sum, $v0: Count</code>). We use register names in
            pseudocode so that the translation to assembly language code will be
            an easy process to perform and because we want documentation that
            describes how the features of the MIPS architecture were used to
            implement the algorithm. Unless we identify the registers being
            used, the pseudocode is quite limited in terms of deriving the
            assembly language program or having any correspondence to the
            assembly language code.
          </p>
          <p>
            Pseudocode for assembly language programs will have the appearance
            of <code>Pascal</code> or <code>C</code> in terms of control
            structures and arithmetic expressions. Descriptive variable names
            will usually appear only in the
            <code>Load Address (la)</code> instruction where there is a
            reference to a symbolic memory address. In assembly language we
            define and allocate space for variables in the data segment of
            memory using assembler directives such as <code>.word</code> and
            <code>.space</code>. Strings are allocated space in memory using the
            assembler directive <code>.asciiz</code>.
          </p>
          <pre>
            <code>
# a program to find the sum of the integers from 1 to "n"
# pseudocode description of algorithm

#main:   count&lt;&lt;"please input a value for N"
#        cin&gt;&gt;v0
#        if(v0&lt;=0)stop
#        t0=0;
#        while(v0&gt;0)do
#              {
#                t0=t0+v0;
#                v0=v0-1;
#              }
#        cout&lt;&lt;t0;
#        go to main

# cross-references:
#   v0:N,
#   t0:Sum

          .data
prompt:   .asciiz   "\n please input a value for N = "
result:   .asciiz   " the sum of the integers from 1 to N is "
bye:      .asciiz   "\n goodbye"
          .globl    main
          .text
main:
          li        $v0,4             # system call code for print string
          la        $a0,prompt        # load address of prompt into $a0
          syscall                     # print the prompt message

          li        $v0,5             # system call code for read integer
          syscall                     # reads the value of N into $v0

          blez      $v0,end           # branch to end if $v0 &lt;= 0
          li        $t0,0             # clear register $t0 to zero
loop:
          add       $t0,$t0,$v0       # sum of integers in register $t0
          addi      $v0,$v0,-1        # summing integers in reverse order
          bnez      $v0,loop          # branch to loop if $v0 is != zero

          li        $v0,4             # system call code for print string
          la        $a0,result        # load address of message into $a0
          syscall                     # print the string

          li        $v0,1             # system call code for print integer
          move      $a0,$t0           # move value to be printed to $a0
          syscall                     # print sum of integers
          b         main              # branch to main

end:      li        $v0,4             # system call code for print string
          la        $a0,bye           # load address of message into $a0
          syscall                     # print the string

          li        $v0,10            # terminate the program run and
          syscall                     # return control to system

            </code>
          </pre>
          <div style="padding-left: 10rem">
            <span
              style="
                font-weight: bolder;
                text-transform: uppercase;
                background-color: yellow;
              "
              >Must have a blank line at the end of the text file</span
            >
          </div>
        </article>
        <article>
          <h3>2.3 Register Usage Convention</h3>
          <p>
            Within the register file, different sets of registers have been
            given names to remind the programmer of a convention, which all MIPS
            assembly language programmers are expected to abide by. If all the
            members of a programming team do not adhere to the same convention,
            the entire effort will result in disaster. To simulate this
            situation, everyone using this book is expected to adhere to the
            same convention. Programs should run correctly, even if the class
            members randomly exchange their functions.
          </p>
          <ul style="list-style: none">
            <li>
              Variables in the main program should be assigned to registers
              <code>$s0</code> through <code>$s7</code>.
            </li>
            <li>
              <span style="font-weight: bolder">Nested Functions:</span>
              functions that call other functions.
            </li>
            <li>
              <span style="font-weight: bolder">Leaf Function:</span> A function
              that does not call another function.
            </li>
            <li>
              Registers <code>$s0</code> through <code>$s7</code> are referred
              to as
              <span style="font-style: italic; font-weight: bold"
                >callee-saved</span
              >
              registers.
            </li>
            <li>
              If additional registers are required within in a function, the
              programmer may only use registers <code>$s0</code> -
              <code>$s7</code> so long as the current registers' values are
              saved on the stack and restores their values before exiting the
              function.
            </li>
            <li>
              Registers <code>$t0</code> through <code>$t9</code> are referred
              to as
              <span style="font-style: italic; font-weight: bold"
                >caller-saved</span
              >
              registers.
            </li>
            <li>
              Registers <code>$t0</code> through <code>$t9</code> can be used
              with the understanding that no other code modules expect values in
              these register will be maintained/managed.
            </li>
            <li>
              If the code module requires that the contents of certain
              "<code>t</code>" registries must be maintained/managed upon return
              from a call to another function, then it is the responsibility of
              the calling module to save these values on the stack and restore
              the values upon returning from the function call.
            </li>
            <li>
              Registries <code>$a0</code> through <code>$a3</code> are used to
              pass arguments to functions.
            </li>
            <li>
              Registries <code>$v0</code> and <code>$v1</code> are used to
              return values from functions.
            </li>
          </ul>
        </article>
      </section>
    </main>
  </body>
</html>
